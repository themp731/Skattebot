{"file_contents":{"config.py":{"content":"\"\"\"Configuration settings for the ESPN Fantasy Football scraper.\"\"\"\n\n# ESPN API endpoints\nESPN_FF_BASE_URL = \"https://fantasy.espn.com/apis/v3/games/ffl\"\nLEAGUE_ENDPOINT = \"/seasons/{year}/segments/0/leagues/{league_id}\"\nBOXSCORE_ENDPOINT = \"/boxscore\"\n\n# API parameters\nDEFAULT_SEASON = 2023\nMAX_WEEK = 17\n\n# CSV output settings\nCSV_HEADERS = {\n    'matchups': [\n        'week', 'matchup_id', 'team_id', 'opponent_id',\n        'team_score', 'opponent_score', 'winner'\n    ],\n    'player_stats': [\n        'week', 'team_id', 'player_id', 'player_name',\n        'position', 'slot_position', 'points', 'projected_points'\n    ],\n    'team_stats': [\n        'week', 'team_id', 'team_name', 'points_for',\n        'points_against', 'weekly_rank'\n    ]\n}\n\n# Output file names\nOUTPUT_FILES = {\n    'matchups': 'matchups.csv',\n    'player_stats': 'player_stats.csv',\n    'team_stats': 'team_stats.csv'\n}\n","size_bytes":895},"csv_generator.py":{"content":"\"\"\"Generate CSV files from processed fantasy football data.\"\"\"\nimport pandas as pd\nfrom typing import Dict\nimport os\nimport logging\n\nclass CSVGenerator:\n    def __init__(self, output_dir: str = \".\"):\n        self.output_dir = output_dir\n        self._ensure_output_dir()\n\n    def _ensure_output_dir(self):\n        \"\"\"Ensure output directory exists.\"\"\"\n        try:\n            if not os.path.exists(self.output_dir):\n                os.makedirs(self.output_dir)\n        except OSError as e:\n            logging.error(f\"Failed to create output directory: {e}\")\n            raise\n\n    def save_dataframe(self, df: pd.DataFrame, filename: str):\n        \"\"\"Save DataFrame to CSV file.\"\"\"\n        try:\n            output_path = os.path.join(self.output_dir, filename)\n            df.to_csv(output_path, index=False)\n            logging.info(f\"Successfully saved {filename}\")\n        except Exception as e:\n            logging.error(f\"Failed to save {filename}: {e}\")\n            raise\n\n    def append_to_csv(self, df: pd.DataFrame, filename: str):\n        \"\"\"Append DataFrame to existing CSV file or create new one.\"\"\"\n        try:\n            output_path = os.path.join(self.output_dir, filename)\n            \n            if os.path.exists(output_path):\n                df.to_csv(output_path, mode='a', header=False, index=False)\n            else:\n                df.to_csv(output_path, index=False)\n                \n            logging.info(f\"Successfully appended to {filename}\")\n        except Exception as e:\n            logging.error(f\"Failed to append to {filename}: {e}\")\n            raise\n","size_bytes":1593},"espn_ff_scraper.py":{"content":"\"\"\"Main script for ESPN Fantasy Football data scraping.\"\"\"\nimport argparse\nimport logging\nfrom datetime import datetime\nimport sys\nfrom typing import Optional\n\nfrom espn_api import ESPNFantasyAPI\nfrom data_processor import DataProcessor\nfrom csv_generator import CSVGenerator\nfrom config import DEFAULT_SEASON, MAX_WEEK, OUTPUT_FILES\n\ndef setup_logging():\n    \"\"\"Configure logging settings.\"\"\"\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(asctime)s - %(levelname)s - %(message)s',\n        handlers=[\n            logging.StreamHandler(sys.stdout)\n        ]\n    )\n\ndef parse_arguments():\n    \"\"\"Parse command line arguments.\"\"\"\n    parser = argparse.ArgumentParser(description='ESPN Fantasy Football Data Scraper')\n    parser.add_argument('--league_id', type=int, required=True,\n                      help='ESPN Fantasy Football League ID')\n    parser.add_argument('--season', type=int, default=DEFAULT_SEASON,\n                      help=f'Season year (default: {DEFAULT_SEASON})')\n    parser.add_argument('--week', type=int,\n                      help=f'Specific week to scrape (default: all weeks)')\n    parser.add_argument('--output', type=str, default='.',\n                      help='Output directory for CSV files')\n    return parser.parse_args()\n\ndef validate_arguments(args) -> bool:\n    \"\"\"Validate command line arguments.\"\"\"\n    if args.season < 2010 or args.season > datetime.now().year:\n        logging.error(f\"Invalid season year: {args.season}\")\n        return False\n    \n    if args.week and (args.week < 1 or args.week > MAX_WEEK):\n        logging.error(f\"Invalid week number: {args.week}\")\n        return False\n        \n    return True\n\ndef main():\n    \"\"\"Main execution function.\"\"\"\n    setup_logging()\n    args = parse_arguments()\n    \n    if not validate_arguments(args):\n        sys.exit(1)\n\n    # Initialize components\n    api = ESPNFantasyAPI(args.league_id, args.season)\n    csv_generator = CSVGenerator(args.output)\n\n    # Validate league\n    if not api.validate_league():\n        logging.error(f\"Invalid or inaccessible league ID: {args.league_id}\")\n        sys.exit(1)\n\n    # Get league data\n    league_data = api.get_league_data()\n    if not league_data:\n        logging.error(\"Failed to fetch league data\")\n        sys.exit(1)\n\n    data_processor = DataProcessor(league_data)\n    \n    # Determine weeks to process\n    weeks = [args.week] if args.week else range(1, MAX_WEEK + 1)\n    \n    for week in weeks:\n        logging.info(f\"Processing week {week}...\")\n        \n        # Fetch boxscore data\n        boxscore_data = api.get_boxscore(week)\n        if not boxscore_data:\n            logging.warning(f\"Skipping week {week} - no data available\")\n            continue\n\n        try:\n            # Process data\n            matchups_df = data_processor.process_matchups(boxscore_data, week)\n            player_stats_df = data_processor.process_player_stats(boxscore_data, week)\n            team_stats_df = data_processor.process_team_stats(boxscore_data, week)\n\n            # Save to CSV\n            csv_generator.append_to_csv(matchups_df, OUTPUT_FILES['matchups'])\n            csv_generator.append_to_csv(player_stats_df, OUTPUT_FILES['player_stats'])\n            csv_generator.append_to_csv(team_stats_df, OUTPUT_FILES['team_stats'])\n            \n            logging.info(f\"Successfully processed week {week}\")\n            \n        except Exception as e:\n            logging.error(f\"Error processing week {week}: {e}\")\n            continue\n\n    logging.info(\"Data scraping completed successfully\")\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":3590},"espn_api.py":{"content":"\"\"\"ESPN Fantasy Football API interaction module.\"\"\"\nimport requests\nfrom typing import Dict, Any, Optional\nimport logging\n\nclass ESPNFantasyAPI:\n    def __init__(self, league_id: int, season: int):\n        self.league_id = league_id\n        self.season = season\n        self.base_url = \"https://fantasy.espn.com/apis/v3/games/ffl\"\n        \n    def get_league_data(self) -> Optional[Dict[str, Any]]:\n        \"\"\"Fetch league data from ESPN API.\"\"\"\n        try:\n            url = f\"{self.base_url}/seasons/{self.season}/segments/0/leagues/{self.league_id}\"\n            response = requests.get(url)\n            response.raise_for_status()\n            return response.json()\n        except requests.exceptions.RequestException as e:\n            logging.error(f\"Failed to fetch league data: {e}\")\n            return None\n\n    def get_boxscore(self, week: int) -> Optional[Dict[str, Any]]:\n        \"\"\"Fetch boxscore data for a specific week.\"\"\"\n        try:\n            params = {\n                'scoringPeriodId': week,\n                'view': ['mBoxscore', 'mMatchupScore']\n            }\n            url = f\"{self.base_url}/seasons/{self.season}/segments/0/leagues/{self.league_id}/matchups\"\n            response = requests.get(url, params=params)\n            response.raise_for_status()\n            return response.json()\n        except requests.exceptions.RequestException as e:\n            logging.error(f\"Failed to fetch boxscore for week {week}: {e}\")\n            return None\n\n    def validate_league(self) -> bool:\n        \"\"\"Validate if the league ID exists and is accessible.\"\"\"\n        try:\n            league_data = self.get_league_data()\n            return league_data is not None and 'id' in league_data\n        except Exception:\n            return False\n","size_bytes":1763},"README.md":{"content":"# ESPN Fantasy Football Data Scraper\n\nThis tool scrapes ESPN fantasy football league box scores and generates BI-ready CSV files.\n\n## Features\n- Fetch box scores from ESPN fantasy football leagues\n- Generate formatted CSV files for BI tools\n- Support for multiple weeks/seasons\n- Progress indicators and error handling\n\n## Usage\n1. Run the script with your league ID:\n   ","size_bytes":371},"data_processor.py":{"content":"\"\"\"Process and transform ESPN Fantasy Football data.\"\"\"\nimport pandas as pd\nfrom typing import Dict, List, Any\nimport logging\n\nclass DataProcessor:\n    def __init__(self, league_data: Dict[str, Any]):\n        self.league_data = league_data\n        self.teams_map = self._create_teams_map()\n\n    def _create_teams_map(self) -> Dict[int, str]:\n        \"\"\"Create a mapping of team IDs to team names.\"\"\"\n        teams_map = {}\n        try:\n            for team in self.league_data.get('teams', []):\n                teams_map[team['id']] = team['name']\n        except KeyError as e:\n            logging.error(f\"Error creating teams map: {e}\")\n        return teams_map\n\n    def process_matchups(self, boxscore_data: Dict[str, Any], week: int) -> pd.DataFrame:\n        \"\"\"Process matchup data into a DataFrame.\"\"\"\n        matchups = []\n        \n        try:\n            for matchup in boxscore_data.get('schedule', []):\n                home_team_id = matchup['home']['teamId']\n                away_team_id = matchup['away']['teamId']\n                home_score = matchup['home']['totalPoints']\n                away_score = matchup['away']['totalPoints']\n                \n                matchups.extend([\n                    {\n                        'week': week,\n                        'matchup_id': matchup['id'],\n                        'team_id': home_team_id,\n                        'opponent_id': away_team_id,\n                        'team_score': home_score,\n                        'opponent_score': away_score,\n                        'winner': home_score > away_score\n                    },\n                    {\n                        'week': week,\n                        'matchup_id': matchup['id'],\n                        'team_id': away_team_id,\n                        'opponent_id': home_team_id,\n                        'team_score': away_score,\n                        'opponent_score': home_score,\n                        'winner': away_score > home_score\n                    }\n                ])\n        except KeyError as e:\n            logging.error(f\"Error processing matchups: {e}\")\n            \n        return pd.DataFrame(matchups)\n\n    def process_player_stats(self, boxscore_data: Dict[str, Any], week: int) -> pd.DataFrame:\n        \"\"\"Process player statistics into a DataFrame.\"\"\"\n        player_stats = []\n        \n        try:\n            for team in boxscore_data.get('teams', []):\n                team_id = team['id']\n                \n                for player in team.get('roster', {}).get('entries', []):\n                    player_stats.append({\n                        'week': week,\n                        'team_id': team_id,\n                        'player_id': player['playerId'],\n                        'player_name': player['playerPoolEntry']['player']['fullName'],\n                        'position': player['playerPoolEntry']['player']['defaultPositionId'],\n                        'slot_position': player['lineupSlotId'],\n                        'points': player['playerPoolEntry']['appliedStatTotal'],\n                        'projected_points': player['playerPoolEntry'].get('projectedPointTotal', 0)\n                    })\n        except KeyError as e:\n            logging.error(f\"Error processing player stats: {e}\")\n            \n        return pd.DataFrame(player_stats)\n\n    def process_team_stats(self, boxscore_data: Dict[str, Any], week: int) -> pd.DataFrame:\n        \"\"\"Process team statistics into a DataFrame.\"\"\"\n        team_stats = []\n        \n        try:\n            teams_data = boxscore_data.get('teams', [])\n            sorted_teams = sorted(teams_data, key=lambda x: x['points'], reverse=True)\n            \n            for rank, team in enumerate(sorted_teams, 1):\n                team_stats.append({\n                    'week': week,\n                    'team_id': team['id'],\n                    'team_name': self.teams_map.get(team['id'], f\"Team {team['id']}\"),\n                    'points_for': team['points'],\n                    'points_against': team['pointsAgainst'],\n                    'weekly_rank': rank\n                })\n        except KeyError as e:\n            logging.error(f\"Error processing team stats: {e}\")\n            \n        return pd.DataFrame(team_stats)\n","size_bytes":4249},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"pandas>=2.2.3\",\n    \"requests>=2.32.3\",\n]\n","size_bytes":189}},"version":2}